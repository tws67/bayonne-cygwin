/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#ifndef _BAYONNE_RPC_H_RPCGEN
#define _BAYONNE_RPC_H_RPCGEN

#include <rpc/rpc.h>


#ifdef __cplusplus
extern "C" {
#endif

/* Copyright (C) 2005 Open Source Telecom Corporation.
 *
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License version 2 as published by the Free Software Foundation.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public License
 * along with this library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.                                                 
 */
#pragma pack(1)
#define BAYONNE_PORT_CALLER_SZ 32
#define BAYONNE_PORT_DIALED_SZ 32
#define BAYONNE_PORT_DISPLAY_SZ 64
#define BAYONNE_PORT_DURATION_SZ 16
#define BAYONNE_PORT_LOGNAME_SZ 16
#define BAYONNE_PORT_SID_SZ 16
#define BAYONNE_NODE_SERVER_SZ 12
#define BAYONNE_NODE_VERSION_SZ 10
#define BAYONNE_SESSION_SZ 32
#define BAYONNE_START_SCRIPT_SZ 32
#define BAYONNE_START_NUMBER_SZ 128
#define BAYONNE_START_CALLER_SZ 32
#define BAYONNE_START_DISPLAY_SZ 64

struct bayonne_status {
	int node_uptime;
	int node_active;
	int node_count;
	char *node_server;
	char *node_version;
};
typedef struct bayonne_status bayonne_status;

struct bayonne_port {
	char *port_cid;
	char *port_pid;
	char *port_logname;
	char *port_caller;
	char *port_dialed;
	char *port_display;
	char *port_duration;
};
typedef struct bayonne_port bayonne_port;

struct bayonne_start {
	char *start_script;
	char *start_number;
	char *start_caller;
	char *start_display;
};
typedef struct bayonne_start bayonne_start;

enum bayonne_error {
	BAYONNE_SUCCESS = 0,
	BAYONNE_FAILURE = 0 + 1,
	BAYONNE_INVALID_VALUES = 0 + 2,
	BAYONNE_INVALID_COMMAND = 0 + 3,
	BAYONNE_INVALID_PORT = 0 + 4,
	BAYONNE_INVALID_SESSION = 0 + 5,
	BAYONNE_INVALID_DRIVER = 0 + 6,
	BAYONNE_INVALID_SCRIPT = 0 + 7,
	BAYONNE_BUSY = 0 + 8,
};
typedef enum bayonne_error bayonne_error;

struct bayonne_result {
	bayonne_error result_code;
	char *result_id;
};
typedef struct bayonne_result bayonne_result;

struct bayonne_session {
	char *session_id;
};
typedef struct bayonne_session bayonne_session;
#pragma pack()

#define BAYONNE_PROGRAM 0x29000001
#define BAYONNE_VERSION 2

#if defined(__STDC__) || defined(__cplusplus)
#define BAYONNE_RELOAD 1
extern  bayonne_error * bayonne_reload_2(void *, CLIENT *);
extern  bayonne_error * bayonne_reload_2_svc(void *, struct svc_req *);
#define BAYONNE_SHUTDOWN 2
extern  bayonne_error * bayonne_shutdown_2(void *, CLIENT *);
extern  bayonne_error * bayonne_shutdown_2_svc(void *, struct svc_req *);
#define BAYONNE_STATUS 3
extern  bayonne_status * bayonne_status_2(void *, CLIENT *);
extern  bayonne_status * bayonne_status_2_svc(void *, struct svc_req *);
#define BAYONNE_START 4
extern  bayonne_result * bayonne_start_2(bayonne_start *, CLIENT *);
extern  bayonne_result * bayonne_start_2_svc(bayonne_start *, struct svc_req *);
#define BAYONNE_STOP 6
extern  bayonne_error * bayonne_stop_2(bayonne_session *, CLIENT *);
extern  bayonne_error * bayonne_stop_2_svc(bayonne_session *, struct svc_req *);
extern int bayonne_program_2_freeresult (SVCXPRT *, xdrproc_t, caddr_t);

#else /* K&R C */
#define BAYONNE_RELOAD 1
extern  bayonne_error * bayonne_reload_2();
extern  bayonne_error * bayonne_reload_2_svc();
#define BAYONNE_SHUTDOWN 2
extern  bayonne_error * bayonne_shutdown_2();
extern  bayonne_error * bayonne_shutdown_2_svc();
#define BAYONNE_STATUS 3
extern  bayonne_status * bayonne_status_2();
extern  bayonne_status * bayonne_status_2_svc();
#define BAYONNE_START 4
extern  bayonne_result * bayonne_start_2();
extern  bayonne_result * bayonne_start_2_svc();
#define BAYONNE_STOP 6
extern  bayonne_error * bayonne_stop_2();
extern  bayonne_error * bayonne_stop_2_svc();
extern int bayonne_program_2_freeresult ();
#endif /* K&R C */

/* the xdr functions */

#if defined(__STDC__) || defined(__cplusplus)
extern  bool_t xdr_bayonne_status (XDR *, bayonne_status*);
extern  bool_t xdr_bayonne_port (XDR *, bayonne_port*);
extern  bool_t xdr_bayonne_start (XDR *, bayonne_start*);
extern  bool_t xdr_bayonne_error (XDR *, bayonne_error*);
extern  bool_t xdr_bayonne_result (XDR *, bayonne_result*);
extern  bool_t xdr_bayonne_session (XDR *, bayonne_session*);

#else /* K&R C */
extern bool_t xdr_bayonne_status ();
extern bool_t xdr_bayonne_port ();
extern bool_t xdr_bayonne_start ();
extern bool_t xdr_bayonne_error ();
extern bool_t xdr_bayonne_result ();
extern bool_t xdr_bayonne_session ();

#endif /* K&R C */

#ifdef __cplusplus
}
#endif

#endif /* !_BAYONNE_RPC_H_RPCGEN */
