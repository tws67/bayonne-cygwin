.TH "ost::URLStream" 3 "2 May 2010" "GNU CommonC++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ost::URLStream \- 
.PP
A URL processing version of \fBTCPStream\fP.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <url.h>\fP
.PP
Inherits \fBost::TCPStream\fP.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBError\fP { \fBerrSuccess\fP =  0, \fBerrUnreachable\fP, \fBerrMissing\fP, \fBerrDenied\fP, \fBerrInvalid\fP, \fBerrForbidden\fP, \fBerrUnauthorized\fP, \fBerrRelocated\fP, \fBerrFailure\fP, \fBerrTimeout\fP, \fBerrInterface\fP }"
.br
.RI "\fIReturn error for url fetch. \fP"
.ti -1c
.RI "enum \fBAuthentication\fP { \fBauthAnonymous\fP =  0, \fBauthBasic\fP }"
.br
.RI "\fIType of authentication. \fP"
.ti -1c
.RI "enum \fBEncoding\fP { \fBencodingBinary\fP =  0, \fBencodingChunked\fP }"
.br
.RI "\fIEncoding used in transfer. \fP"
.ti -1c
.RI "enum \fBMethod\fP { \fBmethodHttpGet\fP, \fBmethodHttpPut\fP, \fBmethodHttpPost\fP, \fBmethodHttpPostMultipart\fP, \fBmethodFtpGet\fP, \fBmethodFtpPut\fP, \fBmethodFileGet\fP, \fBmethodFilePut\fP }"
.br
.RI "\fIType of fetch. \fP"
.ti -1c
.RI "enum \fBProtocol\fP { \fBprotocolHttp1_0\fP, \fBprotocolHttp1_1\fP }"
.br
.RI "\fIhttp protocol version \fP"
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBURLStream\fP (\fBFamily\fP \fBfamily\fP=IPV4, \fBtimeout_t\fP timer=0)"
.br
.RI "\fIConstruct an instance of URL stream. \fP"
.ti -1c
.RI "\fBURLStream\fP & \fBgetline\fP (char *buffer, size_t len)"
.br
.RI "\fILine parsing with conversion. \fP"
.ti -1c
.RI "\fBError\fP \fBget\fP (const char *url, size_t buffer=512)"
.br
.RI "\fIGet URL data from a named stream of a known buffer size. \fP"
.ti -1c
.RI "\fBError\fP \fBget\fP (size_t buffer=512)"
.br
.RI "\fIGet URL data from a named stream of a known buffer size. \fP"
.ti -1c
.RI "\fBError\fP \fBsubmit\fP (const char *url, const char **vars, size_t buffer=512)"
.br
.RI "\fISubmit URL with vars passed as argument array. \fP"
.ti -1c
.RI "\fBError\fP \fBpost\fP (const char *url, const char **vars, size_t buffer=512)"
.br
.RI "\fIPost URL vars with post method. \fP"
.ti -1c
.RI "\fBError\fP \fBpost\fP (const char *url, \fBMIMEMultipartForm\fP &form, size_t buffer=512)"
.br
.RI "\fIPost URL with MIME multipart form. \fP"
.ti -1c
.RI "\fBError\fP \fBhead\fP (const char *url, size_t buffer=512)"
.br
.RI "\fIUsed to fetch header information for a resource. \fP"
.ti -1c
.RI "void \fBclose\fP ()"
.br
.RI "\fIClose the URL stream for a new connection. \fP"
.ti -1c
.RI "void \fBsetReferer\fP (const char *str)"
.br
.RI "\fISet the referer url. \fP"
.ti -1c
.RI "void \fBsetHost\fP (const char *str)"
.br
.RI "\fISet the host for the url. \fP"
.ti -1c
.RI "void \fBsetAddress\fP (const char *str)"
.br
.RI "\fISet the address for the url. \fP"
.ti -1c
.RI "void \fBsetCookie\fP (const char *str)"
.br
.RI "\fISet the cookie to pass. \fP"
.ti -1c
.RI "void \fBsetUser\fP (const char *str)"
.br
.RI "\fISet user id for the url. \fP"
.ti -1c
.RI "void \fBsetPassword\fP (const char *str)"
.br
.RI "\fISet password for the url. \fP"
.ti -1c
.RI "void \fBsetAuthentication\fP (\fBAuthentication\fP a, const char *str=NULL)"
.br
.RI "\fISet authentication type for the url. \fP"
.ti -1c
.RI "void \fBsetProxyUser\fP (const char *str)"
.br
.RI "\fISet proxy user id for the url. \fP"
.ti -1c
.RI "void \fBsetProxyPassword\fP (const char *str)"
.br
.RI "\fISet proxy password for the url. \fP"
.ti -1c
.RI "void \fBsetProxyAuthentication\fP (\fBAuthentication\fP a, const char *str=NULL)"
.br
.RI "\fISet proxy authentication type for the url. \fP"
.ti -1c
.RI "void \fBsetPragma\fP (const char *str)"
.br
.RI "\fISet the pragmas. \fP"
.ti -1c
.RI "void \fBsetProxy\fP (const char *host, \fBtpport_t\fP port)"
.br
.RI "\fISet the proxy server used. \fP"
.ti -1c
.RI "void \fBsetAgent\fP (const char *str)"
.br
.RI "\fISet the agent. \fP"
.ti -1c
.RI "\fBMethod\fP \fBgetMethod\fP (void)"
.br
.RI "\fIGet url method (and protocol) employed. \fP"
.ti -1c
.RI "void \fBsetTimeout\fP (\fBtimeout_t\fP to)"
.br
.RI "\fISet socket timeout characteristics for processing URL requests. \fP"
.ti -1c
.RI "void \fBsetFollow\fP (bool enable)"
.br
.RI "\fISpecify url following. \fP"
.ti -1c
.RI "void \fBsetProtocol\fP (\fBProtocol\fP pro)"
.br
.RI "\fISpecify http protocol level being used. \fP"
.ti -1c
.RI "void \fBsetLocalInterface\fP (const char *intf)"
.br
.RI "\fISpecify local interface to use. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBError\fP \fBsendHTTPHeader\fP (const char *url, const char **vars, size_t \fBbufsize\fP)"
.br
.RI "\fISend http header to server. \fP"
.ti -1c
.RI "int \fBunderflow\fP (void)"
.br
.RI "\fICalled if stream buffer needs refilling. \fP"
.ti -1c
.RI "virtual int \fBaRead\fP (char *buffer, size_t len, \fBtimeout_t\fP timer)"
.br
.RI "\fIDerived method for async or timed I/O function on url stream. \fP"
.ti -1c
.RI "virtual int \fBaWrite\fP (char *buffer, size_t len, \fBtimeout_t\fP timer)"
.br
.RI "\fIDerived method for async or timed I/O function on url stream. \fP"
.ti -1c
.RI "virtual void \fBhttpHeader\fP (const char *header, const char *value)"
.br
.RI "\fIDerived method to receive and parse http 'headers'. \fP"
.ti -1c
.RI "virtual char ** \fBextraHeader\fP (void)"
.br
.RI "\fIA virtual to insert additional header info into the request. \fP"
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBost::String\fP \fBm_host\fP"
.br
.ti -1c
.RI "\fBost::String\fP \fBm_address\fP"
.br
.in -1c
.SS "Related Functions"
(Note that these are not member functions.) 
.in +1c
.ti -1c
.RI "char * \fBurlDecode\fP (char *source, char *dest=NULL)"
.br
.ti -1c
.RI "char * \fBurlEncode\fP (const char *source, char *dest, size_t size)"
.br
.ti -1c
.RI "char * \fBb64Decode\fP (char *src, char *dest=NULL)"
.br
.ti -1c
.RI "char * \fBb64Encode\fP (const char *source, char *dest, size_t size)"
.br
.ti -1c
.RI "size_t \fBb64Encode\fP (const unsigned char *src, size_t srcsize, char *dst, size_t dstsize)"
.br
.ti -1c
.RI "size_t \fBb64Decode\fP (const char *src, unsigned char *dst, size_t dstsize)"
.br
.ti -1c
.RI "\fBString\fP \fBb64Encode\fP (const \fBString\fP &src)"
.br
.ti -1c
.RI "\fBString\fP \fBb64Decode\fP (const \fBString\fP &src)"
.br
.ti -1c
.RI "\fBString\fP \fBb64Encode\fP (const unsigned char *src, size_t srcsize)"
.br
.ti -1c
.RI "size_t \fBb64Decode\fP (const \fBString\fP &src, unsigned char *dst, size_t dstsize)"
.br
.in -1c
.SH "Detailed Description"
.PP 
A URL processing version of \fBTCPStream\fP. 

\fBAuthor:\fP
.RS 4
David Sugar <dyfet@ostel.com> C++ url processing stream class. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
.PP
\fBurlfetch.cpp\fP, and \fBxmlfetch.cpp\fP.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBost::URLStream::Authentication\fP"
.PP
Type of authentication. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIauthAnonymous \fP\fP
.TP
\fB\fIauthBasic \fP\fP

.SS "enum \fBost::URLStream::Encoding\fP"
.PP
Encoding used in transfer. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIencodingBinary \fP\fP
.TP
\fB\fIencodingChunked \fP\fP

.SS "enum \fBost::URLStream::Error\fP"
.PP
Return error for url fetch. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIerrSuccess \fP\fP
.TP
\fB\fIerrUnreachable \fP\fP
.TP
\fB\fIerrMissing \fP\fP
.TP
\fB\fIerrDenied \fP\fP
.TP
\fB\fIerrInvalid \fP\fP
.TP
\fB\fIerrForbidden \fP\fP
.TP
\fB\fIerrUnauthorized \fP\fP
.TP
\fB\fIerrRelocated \fP\fP
.TP
\fB\fIerrFailure \fP\fP
.TP
\fB\fIerrTimeout \fP\fP
.TP
\fB\fIerrInterface \fP\fP

.PP
Reimplemented from \fBost::Socket\fP.
.SS "enum \fBost::URLStream::Method\fP"
.PP
Type of fetch. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fImethodHttpGet \fP\fP
.TP
\fB\fImethodHttpPut \fP\fP
.TP
\fB\fImethodHttpPost \fP\fP
.TP
\fB\fImethodHttpPostMultipart \fP\fP
.TP
\fB\fImethodFtpGet \fP\fP
.TP
\fB\fImethodFtpPut \fP\fP
.TP
\fB\fImethodFileGet \fP\fP
.TP
\fB\fImethodFilePut \fP\fP

.SS "enum \fBost::URLStream::Protocol\fP"
.PP
http protocol version 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIprotocolHttp1_0 \fP\fP
.TP
\fB\fIprotocolHttp1_1 \fP\fP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "ost::URLStream::URLStream (\fBFamily\fP family = \fCIPV4\fP, \fBtimeout_t\fP timer = \fC0\fP)"
.PP
Construct an instance of URL stream. \fBParameters:\fP
.RS 4
\fIfamily\fP protocol to use. 
.br
\fItimer\fP for default timeout on I/O operations. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "virtual int ost::URLStream::aRead (char * buffer, size_t len, \fBtimeout_t\fP timer)\fC [protected, virtual]\fP"
.PP
Derived method for async or timed I/O function on url stream. \fBReturns:\fP
.RS 4
number of bytes read or < 0 for error. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP to read stream data into. 
.br
\fIlen\fP of bytes to read from stream. 
.br
\fItimer\fP to wait for data in milliseconds. 
.RE
.PP

.SS "virtual int ost::URLStream::aWrite (char * buffer, size_t len, \fBtimeout_t\fP timer)\fC [protected, virtual]\fP"
.PP
Derived method for async or timed I/O function on url stream. \fBReturns:\fP
.RS 4
number of bytes written or < 0 for error. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP to write stream data from. 
.br
\fIlen\fP of bytes to write to stream. 
.br
\fItimer\fP to wait for data in milliseconds. 
.RE
.PP

.SS "void ost::URLStream::close ()"
.PP
Close the URL stream for a new connection. 
.SS "virtual char** ost::URLStream::extraHeader (void)\fC [protected, virtual]\fP"
.PP
A virtual to insert additional header info into the request. \fBReturns:\fP
.RS 4
array of header attributes to add. 
.RE
.PP

.SS "\fBError\fP ost::URLStream::get (size_t buffer = \fC512\fP)"
.PP
Get URL data from a named stream of a known buffer size. Requesting URL defined in previous calls of \fBsetAddress()\fP and \fBsetHost()\fP functions.
.PP
\fBReturns:\fP
.RS 4
url error code. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP size of buffer. 
.RE
.PP

.SS "\fBError\fP ost::URLStream::get (const char * url, size_t buffer = \fC512\fP)"
.PP
Get URL data from a named stream of a known buffer size. \fBReturns:\fP
.RS 4
url error code. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIurl\fP name of resource. 
.br
\fIbuffer\fP size of buffer. 
.RE
.PP

.SS "\fBURLStream\fP& ost::URLStream::getline (char * buffer, size_t len)"
.PP
Line parsing with conversion. \fBReturns:\fP
.RS 4
\fBURLStream\fP object reference. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP to store. 
.br
\fIlen\fP maximum buffer size. 
.RE
.PP

.SS "\fBMethod\fP ost::URLStream::getMethod (void)\fC [inline]\fP"
.PP
Get url method (and protocol) employed. \fBReturns:\fP
.RS 4
url method in effect. 
.RE
.PP

.SS "\fBError\fP ost::URLStream::head (const char * url, size_t buffer = \fC512\fP)"
.PP
Used to fetch header information for a resource. \fBReturns:\fP
.RS 4
url error code. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIurl\fP name of resource. 
.br
\fIbuffer\fP size of buffer. 
.RE
.PP

.SS "virtual void ost::URLStream::httpHeader (const char * header, const char * value)\fC [protected, virtual]\fP"
.PP
Derived method to receive and parse http 'headers'. \fBParameters:\fP
.RS 4
\fIheader\fP keyword. 
.br
\fIvalue\fP header keyword value. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBurlfetch.cpp\fP, and \fBxmlfetch.cpp\fP.
.SS "\fBError\fP ost::URLStream::post (const char * url, \fBMIMEMultipartForm\fP & form, size_t buffer = \fC512\fP)"
.PP
Post URL with MIME multipart form. \fBReturns:\fP
.RS 4
success or error code. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIurl\fP name of resource being posted. 
.br
\fIform\fP multi-part resource. 
.br
\fIbuffer\fP size to use. 
.RE
.PP

.SS "\fBError\fP ost::URLStream::post (const char * url, const char ** vars, size_t buffer = \fC512\fP)"
.PP
Post URL vars with post method. \fBReturns:\fP
.RS 4
success or error code. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIurl\fP name of resource being posted. 
.br
\fIvars\fP to set in post. 
.br
\fIbuffer\fP size of buffer. 
.RE
.PP

.SS "\fBError\fP ost::URLStream::sendHTTPHeader (const char * url, const char ** vars, size_t bufsize)\fC [protected]\fP"
.PP
Send http header to server. \fBParameters:\fP
.RS 4
\fIurl\fP base to send header to 
.br
\fIvars\fP to post or use in get method 
.br
\fIbufsize\fP of stream buffering to use 
.RE
.PP
\fBReturns:\fP
.RS 4
success or class error 
.RE
.PP

.SS "void ost::URLStream::setAddress (const char * str)\fC [inline]\fP"
.PP
Set the address for the url. \fBParameters:\fP
.RS 4
\fIstr\fP address in the URL. 
.RE
.PP

.SS "void ost::URLStream::setAgent (const char * str)\fC [inline]\fP"
.PP
Set the agent. \fBParameters:\fP
.RS 4
\fIstr\fP agent value. 
.RE
.PP

.SS "void ost::URLStream::setAuthentication (\fBAuthentication\fP a, const char * str = \fCNULL\fP)"
.PP
Set authentication type for the url. \fBParameters:\fP
.RS 4
\fIa\fP authentication. 
.br
\fIstr\fP string. 
.RE
.PP

.SS "void ost::URLStream::setCookie (const char * str)\fC [inline]\fP"
.PP
Set the cookie to pass. \fBParameters:\fP
.RS 4
\fIstr\fP cookie string. 
.RE
.PP

.SS "void ost::URLStream::setFollow (bool enable)\fC [inline]\fP"
.PP
Specify url following. Set to false to disable following of relocation requests.
.PP
\fBParameters:\fP
.RS 4
\fIenable\fP true to enable following. 
.RE
.PP

.SS "void ost::URLStream::setHost (const char * str)\fC [inline]\fP"
.PP
Set the host for the url. \fBParameters:\fP
.RS 4
\fIstr\fP host address. 
.RE
.PP

.SS "void ost::URLStream::setLocalInterface (const char * intf)\fC [inline]\fP"
.PP
Specify local interface to use. \fBParameters:\fP
.RS 4
\fIintf\fP Local interface name 
.RE
.PP

.SS "void ost::URLStream::setPassword (const char * str)\fC [inline]\fP"
.PP
Set password for the url. \fBParameters:\fP
.RS 4
\fIstr\fP password. 
.RE
.PP

.SS "void ost::URLStream::setPragma (const char * str)\fC [inline]\fP"
.PP
Set the pragmas. \fBParameters:\fP
.RS 4
\fIstr\fP pragma setting. 
.RE
.PP

.SS "void ost::URLStream::setProtocol (\fBProtocol\fP pro)\fC [inline]\fP"
.PP
Specify http protocol level being used. \fBParameters:\fP
.RS 4
\fIpro\fP protocol level. 
.RE
.PP

.SS "void ost::URLStream::setProxy (const char * host, \fBtpport_t\fP port)"
.PP
Set the proxy server used. \fBParameters:\fP
.RS 4
\fIhost\fP proxy host. 
.br
\fIport\fP proxy port. 
.RE
.PP

.SS "void ost::URLStream::setProxyAuthentication (\fBAuthentication\fP a, const char * str = \fCNULL\fP)"
.PP
Set proxy authentication type for the url. \fBParameters:\fP
.RS 4
\fIa\fP authentication. 
.br
\fIstr\fP string. 
.RE
.PP

.SS "void ost::URLStream::setProxyPassword (const char * str)\fC [inline]\fP"
.PP
Set proxy password for the url. \fBParameters:\fP
.RS 4
\fIstr\fP password. 
.RE
.PP

.SS "void ost::URLStream::setProxyUser (const char * str)\fC [inline]\fP"
.PP
Set proxy user id for the url. \fBParameters:\fP
.RS 4
\fIstr\fP user id. 
.RE
.PP

.SS "void ost::URLStream::setReferer (const char * str)"
.PP
Set the referer url. \fBParameters:\fP
.RS 4
\fIstr\fP referer string. 
.RE
.PP

.SS "void ost::URLStream::setTimeout (\fBtimeout_t\fP to)\fC [inline]\fP"
.PP
Set socket timeout characteristics for processing URL requests. Set to 0 for no default timeouts.
.PP
\fBParameters:\fP
.RS 4
\fIto\fP timeout to set. 
.RE
.PP

.PP
Reimplemented from \fBost::TCPStream\fP.
.SS "void ost::URLStream::setUser (const char * str)\fC [inline]\fP"
.PP
Set user id for the url. \fBParameters:\fP
.RS 4
\fIstr\fP user id. 
.RE
.PP

.SS "\fBError\fP ost::URLStream::submit (const char * url, const char ** vars, size_t buffer = \fC512\fP)"
.PP
Submit URL with vars passed as argument array. This submit assumes 'GET' method. Use 'post' member to perform post.
.PP
\fBReturns:\fP
.RS 4
url error code. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIurl\fP name of resource. 
.br
\fIvars\fP to set. 
.br
\fIbuffer\fP size of buffer. 
.RE
.PP

.SS "int ost::URLStream::underflow (void)\fC [protected]\fP"
.PP
Called if stream buffer needs refilling. \fBReturns:\fP
.RS 4
number of bytes refilled or error if < 0 
.RE
.PP

.PP
Reimplemented from \fBost::TCPStream\fP.
.SH "Friends And Related Function Documentation"
.PP 
.SS "size_t b64Decode (const \fBString\fP & src, unsigned char * dst, size_t dstsize)\fC [related]\fP"Decode a string using base64 coding. Destination size should be at least strlen(src)/4*3. Destination are not string terminated (It's just a octet stream). 
.PP
\fBReturns:\fP
.RS 4
number of octets written into destination buffer 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP source string 
.br
\fIdst\fP destination octet buffer 
.br
\fIdstsize\fP destination buffer size 
.RE
.PP

.SS "\fBString\fP b64Decode (const \fBString\fP & src)\fC [related]\fP"Decode a STL string using base64 coding into an STL \fBString\fP. Destination size should be at least strlen(src)/4*3. Destination are not string terminated (It's just a octet stream). 
.PP
\fBReturns:\fP
.RS 4
decoded string 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP source string 
.RE
.PP

.SS "size_t b64Decode (const char * src, unsigned char * dst, size_t dstsize)\fC [related]\fP"Decode a string using base64 coding. Destination size should be at least strlen(src)/4*3. Destination are not string terminated (It's just a octet stream). 
.PP
\fBReturns:\fP
.RS 4
number of octets written into destination buffer 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP source string 
.br
\fIdst\fP destination octet buffer 
.br
\fIdstsize\fP destination buffer size 
.RE
.PP

.SS "char * b64Decode (char * src, char * dest = \fCNULL\fP)\fC [related]\fP"Decode a string using base64 coding. Destination size should be at least strlen(src)+1. Destination will be a string, so is always terminated . This function is deprecated, base64 can use binary source, not only string use overloaded b64Decode. 
.PP
\fBReturns:\fP
.RS 4
string coded 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP source buffer 
.br
\fIdest\fP destination buffer. If NULL src is used 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBurl1.cpp\fP.
.SS "\fBString\fP b64Encode (const unsigned char * src, size_t srcsize)\fC [related]\fP"Encode a octet stream using base64 coding into a STL string 
.PP
\fBReturns:\fP
.RS 4
base 64 encoded string 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP source buffer 
.br
\fIsrcsize\fP source buffer size 
.RE
.PP

.SS "\fBString\fP b64Encode (const \fBString\fP & src)\fC [related]\fP"Encode a STL string using base64 coding into a STL string 
.PP
\fBReturns:\fP
.RS 4
base 64 encoded string 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP source string 
.RE
.PP

.SS "size_t b64Encode (const unsigned char * src, size_t srcsize, char * dst, size_t dstsize)\fC [related]\fP"Encode a octet stream using base64 coding. Destination size should be at least (srcsize+2)/3*4+1. Destination will be a string, so is always terminated (unless you pass dstsize == 0). 
.PP
\fBReturns:\fP
.RS 4
size of string written not counting terminator 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP source buffer 
.br
\fIsrcsize\fP source buffer size 
.br
\fIdst\fP destination buffer 
.br
\fIdstsize\fP destination buffer size 
.RE
.PP

.SS "char * b64Encode (const char * source, char * dest, size_t size)\fC [related]\fP"Encode a string using base64 coding. Destination size should be at least strlen(src)/4*3+1. Destination is string terminated. This function is deprecated, coded stream can contain terminator character use overloaded b64Encode instead. 
.PP
\fBReturns:\fP
.RS 4
destination buffer 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP source string 
.br
\fIdest\fP destination octet buffer 
.br
\fIsize\fP destination buffer size 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBurl1.cpp\fP.
.SS "char * urlDecode (char * source, char * dest = \fCNULL\fP)\fC [related]\fP"Decode an url parameter (ie '\\%20' -> ' ') 
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP string 
.br
\fIdest\fP destination buffer. If NULL source is used 
.RE
.PP

.SS "char * urlEncode (const char * source, char * dest, size_t size)\fC [related]\fP"Encode an url parameter (ie ' ' -> '+') 
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP string 
.br
\fIdest\fP destination buffer. Do not overlap with source 
.br
\fIsize\fP destination buffer size. 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "\fBost::String\fP \fBost::URLStream::m_address\fP\fC [protected]\fP"
.SS "\fBost::String\fP \fBost::URLStream::m_host\fP\fC [protected]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for GNU CommonC++ from the source code.
