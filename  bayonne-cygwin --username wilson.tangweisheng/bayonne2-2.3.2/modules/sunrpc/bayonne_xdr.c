/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "bayonne_rpc.h"
/* Copyright (C) 2005 Open Source Telecom Corporation.
 *
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License version 2 as published by the Free Software Foundation.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public License
 * along with this library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.                                                 
 */

bool_t
xdr_bayonne_status (XDR *xdrs, bayonne_status *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->node_uptime))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->node_active))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->node_count))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->node_uptime);
		IXDR_PUT_LONG(buf, objp->node_active);
		IXDR_PUT_LONG(buf, objp->node_count);
		}
		 if (!xdr_string (xdrs, &objp->node_server, BAYONNE_NODE_SERVER_SZ))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->node_version, BAYONNE_NODE_VERSION_SZ))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->node_uptime))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->node_active))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->node_count))
				 return FALSE;

		} else {
		objp->node_uptime = IXDR_GET_LONG(buf);
		objp->node_active = IXDR_GET_LONG(buf);
		objp->node_count = IXDR_GET_LONG(buf);
		}
		 if (!xdr_string (xdrs, &objp->node_server, BAYONNE_NODE_SERVER_SZ))
			 return FALSE;
		 if (!xdr_string (xdrs, &objp->node_version, BAYONNE_NODE_VERSION_SZ))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->node_uptime))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->node_active))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->node_count))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->node_server, BAYONNE_NODE_SERVER_SZ))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->node_version, BAYONNE_NODE_VERSION_SZ))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_bayonne_port (XDR *xdrs, bayonne_port *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->port_cid, BAYONNE_PORT_SID_SZ))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->port_pid, BAYONNE_PORT_SID_SZ))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->port_logname, BAYONNE_PORT_LOGNAME_SZ))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->port_caller, BAYONNE_PORT_CALLER_SZ))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->port_dialed, BAYONNE_PORT_DIALED_SZ))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->port_display, BAYONNE_PORT_DISPLAY_SZ))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->port_duration, BAYONNE_PORT_DURATION_SZ))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_bayonne_start (XDR *xdrs, bayonne_start *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->start_script, BAYONNE_START_SCRIPT_SZ))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->start_number, BAYONNE_START_NUMBER_SZ))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->start_caller, BAYONNE_START_CALLER_SZ))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->start_display, BAYONNE_START_DISPLAY_SZ))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_bayonne_error (XDR *xdrs, bayonne_error *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_bayonne_result (XDR *xdrs, bayonne_result *objp)
{
	register int32_t *buf;

	 if (!xdr_bayonne_error (xdrs, &objp->result_code))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->result_id, BAYONNE_SESSION_SZ))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_bayonne_session (XDR *xdrs, bayonne_session *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->session_id, BAYONNE_SESSION_SZ))
		 return FALSE;
	return TRUE;
}
